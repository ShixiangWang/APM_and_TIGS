---
title: "TCGA Pan-cancer analyses"
author: "Shixiang Wang"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    lightbox: false
    toc_depth: 3
    mathjax: true
---

```{r include=FALSE}
options(max.print = "75")
knitr::opts_chunk$set(echo = TRUE, comment = "#>", eval = TRUE, collapse = TRUE)
knitr::opts_knit$set(width = 75)
```

This part will clearly describe how to analyze TCGA Pan-cancer data. Raw data used for TCGA pancan analyses have been preprocessed, detail please read preprocessing part of this analysis report.

## Clean and combine data

Although data have been preprocessed in preprocessing part, they are still necessary to do some cleaning before really analyzing them according to our purpose.

```{r library_pkgs_load_data, message=FALSE}
library(tidyverse)

load("results/gsva_tcga_pancan.RData")
load("results/TCGA_tidy_Clinical.RData")

df.gsva <- full_join(TCGA_Clinical.tidy, gsva.pac, by = c("Tumor_Sample_Barcode" = "tsb"))
```

Only keep tumor samples, and filter sample which sample type is "0" or "X". Number of samples with these two sample type are very few.

```{r keep_tumors}
df.gsva.tumor <- df.gsva %>%
  filter(sample_type == "Primary Tumor", !Tumor_stage %in% c("0", "X")) %>%
  mutate(Tumor_stage = factor(Tumor_stage, levels = c("I", "II", "III", "IV")))
```

Totally, 9095 tumor samples have APS value.

## Strong association between APS and immune cell infiltration level

We know that genes used for APS calculation does not overlap with genes of immune cell type, but we don't know if there are association between APS and them. Besides, we also don't know if there are association between APS and two aggregate scores: TIS and IIS.

**UPDATE**: Also, we also want to compare them with APS7, APS calculated with MHC II (substitute MHC I genes with classic MHC II genes), and PHBR scores from *MHC-I Genotype Restricts the Oncogenic Mutational Landscape* and *Evolutionary Pressure against MHC Class II Binding Cancer Mutations*. Therefore, we integrate them all before analyzing.


```{r}
load("results/res_APS7.GSVA.RData")
load("results/res_APS_MHC_II.GSVA.RData")

res_APS7.GSVA <- res_APS7.GSVA %>%
  rownames_to_column(var = "Tumor_Sample_Barcode") %>%
  rename(APS7 = APM)

res_MHCII.GSVA <- res_MHCII.GSVA %>%
  rownames_to_column(var = "Tumor_Sample_Barcode") %>%
  rename(APS_MHC_II = APM_MHC_II)
```

```{r}
load(file = "../data/TCGA.PHBR_I.score.RData")
load(file = "../data/TCGA.PHBR_II.score.RData")

PHBR_I.score <- dplyr::tibble(
  Tumor_Sample_Barcode = paste0(names(PHBR_I.score), "-01"),
  PHBR_I = as.numeric(PHBR_I.score)
)

PHBR_II.score <- dplyr::tibble(
  Tumor_Sample_Barcode = paste0(names(PHBR_II.score), "-01"),
  PHBR_II = as.numeric(PHBR_II.score)
)
```


Combine them.

```{r}
df.gsva.tumor <- purrr::reduce(
  list(df.gsva.tumor, res_APS7.GSVA, res_MHCII.GSVA, PHBR_I.score, PHBR_II.score),
  left_join
)
```


### Association between GSVA scores and other presentation scores

Here we explore association across APS, APS7, APS_MHC_II, PHBR_I, PHBR_II.

```{r relationship_between_scores}
score_df <- df.gsva.tumor %>%
  select(Project, APM, APS7, APS_MHC_II, TIS, IIS, PHBR_I, PHBR_II)
```

First we check pan-cancer level association.

```{r}
cor_mat1 <- cor(score_df %>% select(-Project), method = "spearman", use = "pairwise.complete.obs")
```

Show heatmap.

```{r}
breaksList <- seq(-1, 1, by = 0.01)
colnames(cor_mat1)[colnames(cor_mat1) == "APM"] <- "APS"
rownames(cor_mat1)[rownames(cor_mat1) == "APM"] <- "APS"

pheatmap::pheatmap(cor_mat1,
  display_numbers = TRUE,
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

Second we check cancer type specific level association.

```{r}
cor_mat2 <- score_df %>%
  group_by(Project) %>%
  nest() %>%
  slice(1) %>%
  mutate(cor = map(data, cor, method = "spearman", use = "pairwise.complete.obs"))
```

Here we get 32 correlation matrixes.

```{r}
cor_mat2
```

Output the result pheatmaps to PDF is a good option to observe results.

```{r eval=FALSE}
# old.par <- par(mfrow=c(1, 2))
pdf("Score_correlation_matrix.pdf")

for (i in seq_len(nrow(cor_mat2))) {
  message("Processing ", cor_mat2$Project[i])
  colnames(cor_mat2$cor[[i]])[colnames(cor_mat2$cor[[i]]) == "APM"] <- "APS"
  rownames(cor_mat2$cor[[i]])[rownames(cor_mat2$cor[[i]]) == "APM"] <- "APS"
  print(pheatmap::pheatmap(cor_mat2$cor[[i]],
    display_numbers = TRUE,
    cluster_rows = FALSE, cluster_cols = FALSE,
    main = cor_mat2$Project[i],
    color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
    breaks = breaksList
  ))
}
dev.off()
# par(old.par)
```


### Association between subsets of immune cells and APS

Next we answer the question: **which cells (CIBERSORT scores) or subsets of the IIS scores are most associated with the APS scores**.

The first step is to calculate correlation using  __spearman__ method.

```{r relationship_APS_others}
df.gsva.heat <- df.gsva.tumor %>%
  select(-c(Tumor_Sample_Barcode:Tumor_stage, APS7, APS_MHC_II, IIS, TIS, PHBR_I, PHBR_II)) %>%
  filter(!is.na(APM)) %>%
  select(Project, APM, everything())
heat_mat <- sapply(unique(df.gsva.heat$Project), function(x) {
  mat <- filter(df.gsva.heat, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})
heat_mat <- heat_mat[-1, ]
```

Show plot.

```{r, fig.width=9}
library(pheatmap)
breaksList <- seq(-1, 1, by = 0.01)

pheatmap(heat_mat,
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

This shows that there is strong positive/consistent relationship between APM and immune/T cell infiltration level across TCGA cancer types. These spearman correlation coefficient are showed as a table.

```{r vis_spearman_coef}
DT::datatable(heat_mat,
  options = list(scrollX = TRUE, keys = TRUE), rownames = TRUE
)
```

Thanks to TCGA, we can obtain CIBERSORT results for TCGA patients from paper *The Immune Landscape of Cancer*.

```{r}
cibersort <- data.table::fread("../data/TCGA.Kallisto.fullIDs.cibersort.relative.tsv.gz")
```

Combine APM (score) and CIBERSORT information, calculate correlation and plot heatmap.

```{r}
cibersort_df <- left_join(
  df.gsva.tumor %>%
    select(Tumor_Sample_Barcode, Project, APM) %>%
    filter(!is.na(APM)),
  cibersort %>%
    select(-CancerType) %>%
    rename(Tumor_Sample_Barcode = SampleID) %>%
    mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 15)) %>%
    mutate(Tumor_Sample_Barcode = gsub("\\.", "-", Tumor_Sample_Barcode))
) %>% select(-c(Tumor_Sample_Barcode, P.value, Correlation, RMSE))
```

```{r, message=FALSE, warning=FALSE}
heat_mat2 <- sapply(unique(cibersort_df$Project), function(x) {
  mat <- filter(cibersort_df, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})
heat_mat2 <- heat_mat2[-1, ]
```

```{r, fig.width=9}
pheatmap(heat_mat2,
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

Indeed, APM score correlate with T cell infiltration.

However, we see PHBR_I, PHBR_II does not have relationship with either APS or IIS, does this score correlate with immune cell infiltration?

Let's check it.

```{r}
cibersort_df <- left_join(
  df.gsva.tumor %>%
    select(Tumor_Sample_Barcode, Project, PHBR_I) %>%
    filter(!is.na(PHBR_I)),
  cibersort %>%
    select(-CancerType) %>%
    rename(Tumor_Sample_Barcode = SampleID) %>%
    mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 15)) %>%
    mutate(Tumor_Sample_Barcode = gsub("\\.", "-", Tumor_Sample_Barcode))
) %>% select(-c(Tumor_Sample_Barcode, P.value, Correlation, RMSE))
```

```{r, message=FALSE, warning=FALSE}
heat_mat2 <- sapply(unique(cibersort_df$Project), function(x) {
  mat <- filter(cibersort_df, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})
heat_mat2 <- heat_mat2[-1, ]
```

```{r, fig.width=9}
pheatmap(heat_mat2,
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

Do the same analysis for PHBR_II score.

```{r}
cibersort_df <- left_join(
  df.gsva.tumor %>%
    select(Tumor_Sample_Barcode, Project, PHBR_II) %>%
    filter(!is.na(PHBR_II)),
  cibersort %>%
    select(-CancerType) %>%
    rename(Tumor_Sample_Barcode = SampleID) %>%
    mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 15)) %>%
    mutate(Tumor_Sample_Barcode = gsub("\\.", "-", Tumor_Sample_Barcode))
) %>% select(-c(Tumor_Sample_Barcode, P.value, Correlation, RMSE))
```

```{r, message=FALSE, warning=FALSE}
heat_mat2 <- sapply(unique(cibersort_df$Project), function(x) {
  mat <- filter(cibersort_df, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})
heat_mat2 <- heat_mat2[-1, ]
```

```{r, fig.width=9}
pheatmap(heat_mat2,
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

### IIS is a good representation of immune cell infiltration

Immune/T cell infiltration is a good indicator for ICB response. Here we have seen that APS have strong association with both TIS and IIS. In indivial level, i.e. 9095 samples, we also observe that TIS and IIS are basically same because their correlation coeficient is about 0.91!


```{r}
df.gsva.tumor %>%
  filter(!is.na(IIS)) %>%
  summarise(corr = cor(TIS, IIS, method = "spearman"))
```


Therefore, we should choose one of them for downstream analysis. Finally, we choose IIS not only because it is more comprehensive, but also it is well validated.

* __In vitro validation__ with multiplex immunofluorescence, __in silico validation__ using simulated mixing proportions and comparison between __CIBERSORT and IIS__ have been previously described (__Senbabaoglu, Y. et al__). 


__TIMER__ is another method that can accurately resolve relative fractions of diverse cell types based on gene expression profiles from complex tissues. __To further validate the calculated IIS, we perform TIMER analysis and find that the result of TIMER is highly correlated with the calculated IIS__. 

```{r cmp_timer}
load("results/timer.RData")

df <- dplyr::select(df.gsva.tumor, Project, APM, IIS, APS7, APS_MHC_II, PHBR_I, PHBR_II, Gender, Age, Tumor_stage, OS.time, OS, Tumor_Sample_Barcode)

df_timer <- dplyr::left_join(x = df, y = timer_clean, by = c("Tumor_Sample_Barcode" = "sample"))
```


```{r cmp_timer_IIS, warning=FALSE, message=FALSE}
library(corrplot)

mat_timer_IIS <- df_timer %>%
  select(-c(APM, APS7, APS_MHC_II, PHBR_I, PHBR_II, Gender:Tumor_Sample_Barcode)) %>%
  filter(!is.na(IIS) & !is.na(T_cell.CD8)) %>%
  filter(T_cell.CD8 != 0)
mat_timer_IIS.heat <- sapply(unique(mat_timer_IIS$Project), function(x) {
  mat <- filter(mat_timer_IIS, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})

mat_timer_IIS.heat <- mat_timer_IIS.heat[-1, -22]

p.mat <- sapply(unique(mat_timer_IIS$Project), function(x) {
  mat <- filter(mat_timer_IIS, Project == x)
  mat <- mat[, -1]
  tryCatch(expr = {
    p_mat <- cor.mtest(mat, method = "spearman", conf.level = .95)
    p_mat[[1]][, 1]
  }, error = function(e) {
    rep(NA, 7)
  })
})

p.mat <- p.mat[-1, -22]
col <- colorRampPalette(c("blue", "white", "red"))(200)

corrplot(mat_timer_IIS.heat,
  method = "color", tl.col = "black", tl.srt = 45,
  col = col, p.mat = p.mat, sig.level = 0.05
)
```

The color bar in figure shows correlation coefficient values. The "X" marks relationship does not pass significant test (i.e. p>=0.05).

Even Senbabaoglu et al have checked the relationship between IIS and CIBERSORT in clear cell renal cell carcinoma. Here we 
expand it to all TCGA cancer type with CIBERSORT data and IIS avaiable.

```{r}
df_cibersort <- left_join(
  df.gsva.tumor %>%
    select(Tumor_Sample_Barcode, Project, IIS) %>%
    filter(!is.na(IIS)),
  cibersort %>%
    select(-CancerType) %>%
    rename(Tumor_Sample_Barcode = SampleID) %>%
    mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 15)) %>%
    mutate(Tumor_Sample_Barcode = gsub("\\.", "-", Tumor_Sample_Barcode))
) %>% select(-c(Tumor_Sample_Barcode, P.value, Correlation, RMSE))
```


```{r cmp_CIBERSORT_IIS, warning=FALSE, message=FALSE}

mat_cibersort_IIS.heat <- sapply(unique(df_cibersort$Project), function(x) {
  mat <- filter(df_cibersort, Project == x)
  mat <- mat[, -1]
  cor_mat <- cor(mat, method = "spearman", use = "pairwise.complete.obs")
  cor_mat[, 1]
})

pheatmap(heat_mat2[-1, ],
  color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
  breaks = breaksList
)
```

Compare with timer, the relationship between IIS and immune cell subsets is more variable. 
I think this can be explained by several reasons:

* CIBERSORT and TIMER target different aspects of tumor immune infiltrates. CIBERSORT infers the relative fractions of immune subsets in the total leukocyte population, while TIMER predicts the abundance of immune cells in the overall tumor microenvironment. Currently both methods are limited by the assumption that transcriptomes of tumor-infiltrating immune cells do not significantly differ from those collected from peripheral blood of healthy donors. (This is from [Revisit linear regression-based deconvolution methods for tumor gene expression data](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-017-1256-5))
* Many cibersort values are equal to 0 or close to 0, this reduce the power to calculate correlation
* CIBERSORT predicts 22 immune cell subsets while TIMER obtains 6 cell types, it is not unexpected to observe a more variable result using CIBERSORT.


## Exploration of APS, TMB, TIGS at pan-cancer level

Load TCGA TMB data and merge all necessary datasets.

```{r}
load("results/TCGA_TMB.RData")

df2 <- df %>%
  mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 12)) %>%
  arrange(APM) %>%
  distinct(Tumor_Sample_Barcode, .keep_all = TRUE)
tcga_all <- full_join(df2, TCGA_TMB, by = "Tumor_Sample_Barcode")

if (!file.exists("results/TCGA_ALL.RData")) {
  save(tcga_all, file = "results/TCGA_ALL.RData")
}

rm(list = ls())
```

Tumor mutation burden (TMB) is defined as __the number of non-synonymous alterations per megabase (Mb) of genome examined__. As reported previously, here we use 38 Mb as the estimate of the exome size. For studies reporting mutation number from whole exome sequencing, the normalized TMB = (whole exome non-synonymous mutation)/(38 Mb). 

Original APM scores (APS) from GSVA are in the range of -1 to 1. To calculate tumor immunogenicity score (TIGS), original APM score from GSVA implementation is rescaled by minimal and maximal APM score from TCGA Pan-cancer analysis. 

We calculate tumor immunogenicity score (TIGS) as following: 

$$
TIGS = APS_{normalized} \times log(TMB + 1)
$$

> Natural logarithm is applied here. Of note, some tumors have TMB level below 1 mutation/ Mb, to avoid minus number in quantifying “tumor antigenicity”, we add number 1 to all normalized TMB.

How we generate this TIGS formula will be described at an individual part. __Here we focus on association of APS, TMB and TIGS and their effects.__

```{r}
load("results/TCGA_ALL.RData")

tcga_all <- tcga_all %>%
  mutate(
    nAPM = (APM - min(APM, na.rm = TRUE)) / (max(APM, na.rm = TRUE) - min(APM, na.rm = TRUE)),
    nTMB = TMB_NonsynVariants / 38,
    TIGS = log(nTMB + 1) * nAPM
  ) %>%
  rename(Event = OS, Time = OS.time)


# keep samples with survival information
df_os <- tcga_all %>%
  filter(!is.na(Time), !is.na(Event))


df_os %>%
  filter(!is.na(nAPM)) %>%
  group_by(Project) %>%
  summarise(N = n()) %>%
  arrange(N)

df_os %>%
  filter(!is.na(TIGS)) %>%
  group_by(Project) %>%
  summarise(N = n()) %>%
  arrange(N)
```


### Distribution of APS, TMB and IIS across TCGA studies

Calculate median values to sort distribution.

```{r calc_median}
#------------ TIGS, TMB, APM pancan, sort by value
df_summary <- df_os %>%
  group_by(Project) %>%
  summarise(
    medianAPM = median(APM, na.rm = TRUE),
    medianTMB = median(TMB_NonsynVariants, na.rm = TRUE),
    medianTIGS = median(TIGS, na.rm = TRUE),
    medianAPMn = median(nAPM, na.rm = TRUE),
    medianTMBn = log(median(nTMB, na.rm = TRUE) + 1)
  )
```


Distribution of APM score (APS) across TCGA studies.

```{r dist_of_APS, message=FALSE, warning=FALSE}
library(scales)
library(ggpubr)

df_os %>%
  filter(!is.na(Project), !is.na(APM)) %>%
  ggboxplot(
    x = "Project", y = "APM", color = "Project", add = "jitter", xlab = "TCGA Projects",
    ylab = "APM Score", add.params = list(size = 0.6),
    legend = "none"
  ) +
  rotate_x_text(angle = 45) +
  geom_hline(yintercept = mean(df_os$APM, na.rm = TRUE), linetype = 2) +
  scale_x_discrete(limits = arrange(df_summary, medianAPM) %>% .$Project) -> p_apm
p_apm
```


Distribution of TMB across TCGA studies.

```{r dist_of_TMB}
df_os %>%
  filter(!is.na(Project), !is.na(TMB_NonsynVariants)) %>%
  ggboxplot(
    x = "Project", y = "TMB_NonsynVariants", color = "Project", add = "jitter", xlab = "TCGA Projects",
    ylab = "No. of Coding Somatic Nonsynonymous Mutation", add.params = list(size = 0.6),
    legend = "none"
  ) +
  rotate_x_text(angle = 45) +
  geom_hline(yintercept = mean(df_os$TMB_NonsynVariants, na.rm = TRUE), linetype = 2) +
  scale_y_log10(breaks = 10^(-1:4), labels = trans_format("log10", math_format(10^.x))) +
  scale_x_discrete(limits = arrange(df_summary, medianTMB) %>% .$Project) -> p_tmb
p_tmb
```

Distribution of TIGS across TCGA studies.

```{r dist_of_TIGS}
df_os %>%
  filter(!is.na(Project), !is.na(TIGS)) %>%
  ggboxplot(
    x = "Project", y = "TIGS", color = "Project", add = "jitter", xlab = "TCGA Projects",
    ylab = "TIGS", add.params = list(size = 0.6),
    legend = "none"
  ) +
  rotate_x_text(angle = 45) +
  geom_hline(yintercept = mean(df_os$TIGS, na.rm = TRUE), linetype = 2) +
  scale_x_discrete(limits = arrange(df_summary, medianTIGS) %>% .$Project) -> p_tigs
p_tigs
```

### Correlation between TMB and IIS 

```{r}
df_TMB <- df_os %>%
  filter(!is.na(IIS), !is.na(TMB_NonsynVariants)) %>%
  mutate(logTMB = log(nTMB + 1))

ggstatsplot::ggscatterstats(
  data = df_TMB,
  x = nTMB,
  y = IIS,
  xlab = "No. of Coding Somatic Nonsynonymous Mutation",
  ylab = "IIS Score",
  point.size = 1,
  # title = "Correlation between APM and IIS score in pancancer",
  messages = FALSE, type = "spearman"
)


ggstatsplot::ggscatterstats(
  data = df_TMB,
  x = logTMB,
  y = IIS,
  xlab = "No. of Coding Somatic Nonsynonymous Mutation (log)",
  ylab = "IIS Score",
  point.size = 1,
  # title = "Correlation between APM and IIS score in pancancer",
  messages = FALSE, type = "spearman"
)

plot_scatter <- function(data, x, y, xlab = "Median APM", ylab = "Median IIS", conf.int = TRUE, method = "spearman", label.x = -0.5, label.y = 0.2, label = "Project", ...) {
  ggscatter(data,
    x = x, y = y,
    xlab = xlab, ylab = ylab,
    shape = 21, size = 3, color = "black",
    add = "reg.line", add.params = list(color = "blue", fill = "lightgray"),
    conf.int = conf.int,
    cor.coef = TRUE,
    cor.coeff.args = list(method = method, label.x = label.x, label.y = label.y, label.sep = "\n"),
    label = label, repel = TRUE, ...
  )
}

df_project <- df_TMB %>%
  group_by(Project) %>%
  summarise(
    TMB_median = median(nTMB, na.rm = TRUE),
    IIS_median = median(IIS, na.rm = TRUE)
  )

mean(df_TMB$nTMB)
plot_scatter(df_project,
  x = "TMB_median", y = "IIS_median",
  xlab = "Median TMB", ylab = "Median IIS", label.x = 0.2
) +
  geom_hline(yintercept = 0, linetype = 2) + geom_vline(xintercept = 4.35, linetype = 2)
```


### Significant correlation between APM score and IIS


```{r}
ggstatsplot::ggscatterstats(
  data = df_os %>% filter(!is.na(APM)),
  x = APM,
  y = IIS,
  xlab = "APM Score",
  ylab = "IIS Score",
  point.size = 1,
  # title = "Correlation between APM and IIS score in pancancer",
  messages = FALSE, type = "spearman"
)

df_project2 <- df_os %>%
  filter(!is.na(APM)) %>%
  group_by(Project) %>%
  summarise(
    APM_median = median(APM),
    IIS_median = median(IIS)
  )

plot_scatter(df_project2,
  x = "APM_median", y = "IIS_median",
  xlab = "Median APM", ylab = "Median IIS"
) +
  geom_hline(yintercept = 0, linetype = 2) + geom_vline(xintercept = 0, linetype = 2)
```

### Survival analysis

Check pan-cancer level influence of APS, TMB and TIGS using unvariable cox model.

```{r}
library(survival)
fit_APS <- coxph(Surv(Time, Event) ~ nAPM, data = filter(df_os, !is.na(nAPM)))
fit_TMB <- coxph(Surv(Time, Event) ~ log(nTMB), data = filter(df_os, !is.na(nTMB)))
fit_TIGS <- coxph(Surv(Time, Event) ~ TIGS, data = filter(df_os, !is.na(TIGS)))
```

```{r}
fit_APS
fit_TMB
fit_TIGS
```

```{r}
dplyr::tibble(
  Variable = c("APS", "TMB", "TIGS"),
  N = c(summary(fit_APS)$n, summary(fit_TMB)$n, summary(fit_TIGS)$n),
  Coef = c(summary(fit_APS)$conf.int[1], summary(fit_TMB)$conf.int[1], summary(fit_TIGS)$conf.int[1]),
  Lower = c(summary(fit_APS)$conf.int[3], summary(fit_TMB)$conf.int[3], summary(fit_TIGS)$conf.int[3]),
  Upper = c(summary(fit_APS)$conf.int[4], summary(fit_TMB)$conf.int[4], summary(fit_TIGS)$conf.int[4]),
  P.value = c(summary(fit_APS)$logtest[3], summary(fit_TMB)$logtest[3], summary(fit_TIGS)$logtest[3])
)
```


We access survival effects of APS, TMB and TIGS across TCGA studies using unvariable cox model.

Firstly, we implement cox model and then obtain key result values from fit, i.e. p value and corresponding 95% confident interval.

```{r}
library(survival)
# calculate APM cox model by project
model_APM <- df_os %>%
  filter(!is.na(nAPM)) %>%
  group_by(Project) %>%
  dplyr::do(coxfit = coxph(Surv(time = Time, event = Event) ~ nAPM, data = .)) %>%
  summarise(
    Project = Project,
    Coef = summary(coxfit)$conf.int[1],
    Lower = summary(coxfit)$conf.int[3],
    Upper = summary(coxfit)$conf.int[4],
    Pvalue = summary(coxfit)$logtest[3]
  )

# use nTMB or log(nTMB)
model_TMB <- df_os %>%
  filter(!is.na(nTMB)) %>%
  group_by(Project) %>%
  dplyr::do(coxfit = coxph(Surv(time = Time, event = Event) ~ log(nTMB), data = .)) %>%
  summarise(
    Project = Project,
    Coef = summary(coxfit)$conf.int[1],
    Lower = summary(coxfit)$conf.int[3],
    Upper = summary(coxfit)$conf.int[4],
    Pvalue = summary(coxfit)$logtest[3]
  )

model_TIGS <- df_os %>%
  filter(!is.na(TIGS)) %>%
  group_by(Project) %>%
  dplyr::do(coxfit = coxph(Surv(time = Time, event = Event) ~ TIGS, data = .)) %>%
  summarise(
    Project = Project,
    Coef = summary(coxfit)$conf.int[1],
    Lower = summary(coxfit)$conf.int[3],
    Upper = summary(coxfit)$conf.int[4],
    Pvalue = summary(coxfit)$logtest[3]
  )

N_APM <- df_os %>%
  filter(!is.na(nAPM)) %>%
  group_by(Project) %>%
  summarise(N = n())

N_TMB <- df_os %>%
  filter(!is.na(nTMB)) %>%
  group_by(Project) %>%
  summarise(N = n())

N_TIGS <- df_os %>%
  filter(!is.na(TIGS)) %>%
  group_by(Project) %>%
  summarise(N = n())


cox_APM <- full_join(model_APM, N_APM)
cox_TMB <- full_join(model_TMB, N_TMB)
cox_TIGS <- full_join(model_TIGS, N_TIGS)


save(cox_APM, cox_TMB, cox_TIGS, df_summary, file = "results/unicox.RData")
```

**UPDATE**: Adjust p values and order them by median APM/TMB/TIGS.


```{r}
cox_APM <- cox_APM %>%
  mutate(Pvalue = p.adjust(Pvalue, method = "fdr")) %>%
  arrange(factor(Project, levels = arrange(df_summary, medianAPM) %>% .$Project))

cox_TMB <- cox_TMB %>%
  mutate(Pvalue = p.adjust(Pvalue, method = "fdr")) %>%
  arrange(factor(Project, levels = arrange(df_summary, medianTMB) %>% .$Project))

cox_TIGS <- cox_TIGS %>%
  mutate(Pvalue = p.adjust(Pvalue, method = "fdr")) %>%
  arrange(factor(Project, levels = arrange(df_summary, medianTIGS) %>% .$Project))
```


Secondly, we generate forest plot.

```{r, fig.width=10, fig.height=10}
library(forestplot)

########### Forest plot

#------ APM
options(digits = 2)
forest_APM <- rbind(
  c("Project", NA, NA, NA, "fdr", "No."),
  cox_APM
) %>% as.data.frame()
forest_APM$HR <- c("HR", format(as.numeric(forest_APM$Coef[-1]), digits = 2))
forest_APM$Pvalue <- c("fdr", format(as.numeric(forest_APM$Pvalue[-1]), digits = 2))

forestplot(
  fn.ci_norm = fpDrawCircleCI,
  forest_APM[, c("Project", "N", "HR", "Pvalue")],
  mean = c(NA, log(cox_APM$Coef)), lower = c(NA, log(cox_APM$Lower)), upper = c(NA, log(cox_APM$Upper)),
  is.summary = c(TRUE, rep(FALSE, 32)),
  clip = c(-4, 4), zero = 0,
  col = fpColors(box = "royalblue", line = "black", summary = "royalblue", hrz_lines = "black"),
  vertices = TRUE,
  xticks = c(-4, -2, -1, 0, 1, 2, 4),
  hrzl_lines = list("2" = gpar(lty = 1, col = "black")),
  boxsize = 0.5,
  # graph.pos = 3,
  xlab = "log Hazard Ratio"
)


#----- TMB
forest_TMB <- rbind(
  c("Project", NA, NA, NA, "fdr", "No."),
  cox_TMB
) %>% as.data.frame()
forest_TMB$HR <- c("HR", format(as.numeric(forest_TMB$Coef[-1]), digits = 2))
forest_TMB$Pvalue <- c("fdr", format(as.numeric(forest_TMB$Pvalue[-1]), digits = 2))


forestplot(
  fn.ci_norm = fpDrawCircleCI,
  forest_TMB[, c("Project", "N", "HR", "Pvalue")],
  mean = c(NA, log(cox_TMB$Coef)), lower = c(NA, log(cox_TMB$Lower)), upper = c(NA, log(cox_TMB$Upper)),
  is.summary = c(TRUE, rep(FALSE, 32)),
  clip = c(-4, 4), zero = 0,
  col = fpColors(box = "royalblue", line = "black", summary = "royalblue", hrz_lines = "black"),
  vertices = TRUE,
  xticks = c(-4, -2, -1, 0, 1, 2, 4),
  hrzl_lines = list("2" = gpar(lty = 1, col = "black")),
  boxsize = 0.5,
  # graph.pos = 3,
  xlab = "log Hazard Ratio"
)


#---------- TIGS
forest_TIGS <- rbind(
  c("Project", NA, NA, NA, "fdr", "No."),
  cox_TIGS
) %>% as.data.frame()
forest_TIGS$HR <- c("HR", format(as.numeric(forest_TIGS$Coef[-1]), digits = 2))
forest_TIGS$Pvalue <- c("fdr", format(as.numeric(forest_TIGS$Pvalue[-1]), digits = 2))


forestplot(
  fn.ci_norm = fpDrawCircleCI,
  forest_TIGS[, c("Project", "N", "HR", "Pvalue")],
  mean = c(NA, log(cox_TIGS$Coef)), lower = c(NA, log(cox_TIGS$Lower)), upper = c(NA, log(cox_TIGS$Upper)),
  is.summary = c(TRUE, rep(FALSE, 32)),
  clip = c(-4, 4), zero = 0,
  col = fpColors(box = "royalblue", line = "black", summary = "royalblue", hrz_lines = "black"),
  vertices = TRUE,
  xticks = c(-4, -2, -1, 0, 1, 2, 4),
  hrzl_lines = list("2" = gpar(lty = 1, col = "black")),
  boxsize = 0.5,
  # graph.pos = 3,
  xlab = "log Hazard Ratio"
)
```

## APS, TIGS and B2M mutation

Obtain B2M mutation status.

```{r, eval=FALSE}
rm(list = ls())

# load package
require(TCGAmutations)


study_list <- tcga_available()$Study_Abbreviation[-34]
cohorts <- system.file("extdata", "cohorts.txt", package = "TCGAmutations")
cohorts <- data.table::fread(input = cohorts)

# calculate TMB
lapply(study_list, function(study) {
  require(maftools)
  TCGAmutations::tcga_load(study)
  maf <- eval(as.symbol(tolower(paste0("TCGA_", study, "_mc3"))))
  maf@data %>%
    group_by(Tumor_Sample_Barcode) %>%
    summarise(B2M = sum(grepl("^B2M$", Hugo_Symbol)))
}) -> tcga_b2m
names(tcga_b2m) <- study_list

# 33 study available, merge them
TCGA_B2M <- purrr::reduce(tcga_b2m, dplyr::bind_rows)

if (!file.exists("results/TCGA_B2M.RData")) {
  save(TCGA_B2M, file = "results/TCGA_B2M.RData")
}

rm(list = grep("tcga_*", ls(), value = TRUE))
rm(list = ls())
```

```{r}
rm(list = ls())
load(file = "results/TCGA_B2M.RData")
load(file = "results/TCGA_ALL.RData")

tcga_all <- tcga_all %>%
  mutate(
    nAPM = (APM - min(APM, na.rm = TRUE)) / (max(APM, na.rm = TRUE) - min(APM, na.rm = TRUE)),
    nTMB = TMB_NonsynVariants / 38,
    TIGS = log(nTMB + 1) * nAPM
  )

df_b2m <-
  dplyr::inner_join(tcga_all, TCGA_B2M, by = "Tumor_Sample_Barcode")

table(df_b2m$B2M)

df_b2m <- df_b2m %>%
  dplyr::mutate(
    B2M_Status = ifelse(B2M > 0, "Mutant", "WT")
  ) %>%
  dplyr::filter(!is.na(APM), !is.na(TIGS), !is.na(B2M))
```


```{r}
table(df_b2m$B2M_Status)
```


```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "APM",
  ylab = "APS", xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "t.test", label.x = 1.3)
```

```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "TIGS",
  xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "t.test", label.x = 1.3)
```

```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "TMB_NonsynVariants",
  ylab = "TMB", xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "wilcox.test", label.x = 1.3)
```

Focus on tructing mutation https://www.nejm.org/doi/10.1056/NEJMoa1604958?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%3dwww.ncbi.nlm.nih.gov

```{r, eval=FALSE}
rm(list = ls())

# load package
require(TCGAmutations)


study_list <- tcga_available()$Study_Abbreviation[-34]
cohorts <- system.file("extdata", "cohorts.txt", package = "TCGAmutations")
cohorts <- data.table::fread(input = cohorts)

# calculate TMB
lapply(study_list, function(study) {
  require(maftools)
  TCGAmutations::tcga_load(study)
  maf <- eval(as.symbol(tolower(paste0("TCGA_", study, "_mc3"))))
  rbind(maf@data, maf@maf.silent) %>%
    group_by(Tumor_Sample_Barcode) %>%
    summarise(B2M = sum(grepl("^B2M$", Hugo_Symbol)
    & Variant_Classification %in% c("Nonsense_Mutation")))
}) -> tcga_b2m
names(tcga_b2m) <- study_list

# 33 study available, merge them
TCGA_B2M <- purrr::reduce(tcga_b2m, dplyr::bind_rows)

if (!file.exists("results/TCGA_B2M2.RData")) {
  save(TCGA_B2M, file = "results/TCGA_B2M2.RData")
}

rm(list = grep("tcga_*", ls(), value = TRUE))
rm(list = ls())
```

```{r}
rm(list = ls())
load(file = "results/TCGA_B2M2.RData")
load(file = "results/TCGA_ALL.RData")

tcga_all <- tcga_all %>%
  mutate(
    nAPM = (APM - min(APM, na.rm = TRUE)) / (max(APM, na.rm = TRUE) - min(APM, na.rm = TRUE)),
    nTMB = TMB_NonsynVariants / 38,
    TIGS = log(nTMB + 1) * nAPM
  )

df_b2m <-
  dplyr::inner_join(tcga_all, TCGA_B2M, by = "Tumor_Sample_Barcode")

table(df_b2m$B2M)

df_b2m <- df_b2m %>%
  dplyr::mutate(
    B2M_Status = ifelse(B2M > 0, "Nonsense", "Non-nonsense")
  ) %>%
  dplyr::filter(!is.na(APM), !is.na(TIGS), !is.na(B2M))
```


```{r}
table(df_b2m$B2M_Status)
```


```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "APM",
  ylab = "APS", xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "t.test", label.x = 1.3)
```

```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "TIGS",
  xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "t.test", label.x = 1.3)
```

```{r}
ggpubr::ggboxplot(
  df_b2m,
  x = "B2M_Status", y = "TMB_NonsynVariants",
  ylab = "TMB", xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "wilcox.test", label.x = 1.3)
```


Check gene expression in these mutant samples.

```{r}
load("results/TCGA_RNASeq_PanCancer.RData")
B2M_expr <- RNASeq_pancan %>%
  dplyr::filter(sample == "B2M") %>%
  dplyr::select(-sample) %>%
  as.numeric()

B2M_expr <- dplyr::tibble(
  Tumor_Sample_Barcode = colnames(RNASeq_pancan)[-1],
  B2M_expr = B2M_expr
) %>%
  dplyr::filter(substr(Tumor_Sample_Barcode, 14, 15) == "01") %>%
  dplyr::mutate(Tumor_Sample_Barcode = substr(Tumor_Sample_Barcode, 1, 12))
```

```{r}
B2M_expr <- dplyr::left_join(
  df_b2m,
  B2M_expr
)
```

```{r}
ggpubr::ggboxplot(
  B2M_expr,
  x = "B2M_Status", y = "B2M_expr",
  xlab = "B2M mutation status"
) +
  ggpubr::stat_compare_means(method = "t.test", label.x = 1.3)
```

```{r}
rm(list = ls())
```


Therefore, APS/TIGS cannot capture whether B2M lose function or not. However, we do 
observe that B2M mutation upgrade APS/TIGS, this may be explained by compensatory expression of APS gene signature.

## Gene sets enriched in patients with high APM score

To identify the __specific gene sets/pathway__ associated with high APS, we firstly run differential gene expression analysis for each TCGA cancer type based on APS status. Patients with APS of first quartile was defined as “APS-High”, patients with APS of the forth quartile was defined as “APS-Low”. Genes with p value <0.01 and FDR <0.05 were ranked by logFC from top to bottom and then inputted into GSEA function of R package [__clusterProfiler__](https://www.bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html) with custom gene sets download from [__Molecular Signature Database v6.2__](http://software.broadinstitute.org/gsea/downloads.jsp).  Normalized enrichment score (NES) was used to rank the differentially enriched gene sets. In results from hallmark gene sets, several gene signatures (especially interferon alpha/gamma response) were found to be enriched in most TCGA cancer types with high APS, suggesting high APS are strongly associated with interferon alpha/gamma signaling pathway. 

The code below is runned on linux server (need much time), thus if reader wanna reproduce it, you may need to download gene sets from [__Molecular Signature Database v6.2__](http://software.broadinstitute.org/gsea/downloads.jsp) and modify some file path.

```{r eval=FALSE}
rm(list = ls())
#----------------------------------------
# APM DEG and Pathway Enrichment Analysis
#----------------------------------------
library(tidyverse)

load("results/TCGA_RNASeq_PanCancer.RData")
load("results/gsva_tcga_pancan.RData")
load("results/TCGA_tidy_Clinical.RData")

df.gsva <- full_join(TCGA_Clinical.tidy, gsva.pac, by = c("Tumor_Sample_Barcode" = "tsb"))

tcga_info <- df.gsva
rm(df.gsea, df.gsva)
gc()

tcga_info <- tcga_info %>%
  select(Project:OS.time, Age, Gender, sample_type, Tumor_stage, APM) %>%
  filter(!is.na(APM))

projects <- unique(tcga_info[, "Project"])
samples <- colnames(RNASeq_pancan)[-1]

#-----------------------------------
# Build a workflow to calculate DEGs
#-----------------------------------
findDEGs <- function(info_df = NULL, expr_df = NULL, col_sample = "Tumor_Sample_Barcode", col_group = "APM",
                     col_subset = "Project", method = "limma", threshold = 0.25,
                     save = FALSE, filename = NULL) {
  stopifnot(!is.null(info_df), !is.null(expr_df))
  stopifnot(threshold >= 0 & threshold <= 1)

  if (!require(data.table)) {
    install.packages("data.table", dependencies = TRUE)
  }

  info_df <- setDT(info_df[, c(col_sample, col_group, col_subset)])
  colnames(info_df) <- c("sample", "groupV", "subset")
  info_df <- info_df[sample %in% colnames(expr_df)]
  info_df <- info_df[!is.na(subset)]
  all_sets <- unique(info_df[, subset])


  if ("DEGroup" %in% colnames(info_df)) {
    stop("DEGroup column exists, please rename and re-run.")
  }

  # set threshold
  th1 <- threshold
  th2 <- 1 - th1

  info_df[, DEGroup := ifelse(groupV < quantile(groupV, th1), "Low",
    ifelse(groupV > quantile(groupV, th2), "High", NA)
  ), by = subset]
  info_df <- info_df[!is.na(DEGroup)]
  sets <- unique(info_df[, subset])
  may_del <- setdiff(all_sets, sets)
  if (length(may_del) != 0) {
    message("Following groups has been filtered out because of threshold setting, you better check")
    print(may_del)
  }

  info_list <- lapply(sets, function(x) info_df[subset == x])
  names(info_list) <- sets

  col1 <- colnames(expr_df)[1]


  options(digits = 4)

  doDEG <- function(input, method = NULL) {
    #-- prepare
    exprSet <- expr_df[, c(col1, input$sample)]
    exprSet <- as.data.frame(exprSet)
    exprSet <- na.omit(exprSet)
    input <- as.data.frame(input)
    rownames(exprSet) <- exprSet[, 1]
    exprSet <- exprSet[, -1]


    sample_tb <- table(input$DEGroup)

    #--- make sure have some samples
    if (!length(sample_tb) < 2 & all(sample_tb >= 5)) {
      group_list <- input$DEGroup

      if ("limma" %in% method) {
        suppressMessages(library(limma))
        design <- model.matrix(~ 0 + factor(group_list))
        colnames(design) <- c("High", "Low")
        cont.matrix <- makeContrasts("High-Low", levels = design)

        fit <- lmFit(exprSet, design)
        fit2 <- contrasts.fit(fit, cont.matrix)
        fit2 <- eBayes(fit2)
        topTable(fit2, number = Inf, adjust.method = "BH")
      }
    }
  }

  res <- lapply(info_list, doDEG, method = method)
  names(res) <- sets
  return(res)
}

# threshold = 0.25 is used in manuscript
# DEG_pancan2 = findDEGs(info_df = tcga_info, expr_df = RNASeq_pancan)
# Here we use threshold = 0.5 to do this analysis to respond
# reviewer's comment
DEG_pancan2 <- findDEGs(info_df = tcga_info, expr_df = RNASeq_pancan, threshold = 0.5)
save(DEG_pancan2, file = "results/DEG_pancan.RData")

#----------------------------------------------------
# Pathway enrichment analysis using clusterProfiler
#--------------------------------------------------
load(file = "results/DEG_pancan.RData")
library(clusterProfiler)
library(tidyverse)
library(openxlsx)

#---------------

## - setting
pvalue <- 0.01
adj.pvalue <- 0.05

## - process

#------- Reading GSEA genesets files
hallmark <- read.gmt("/public/data/VM_backup/biodata/MsigDB/h.all.v6.2.symbols.gmt")
c1 <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c1.all.v6.2.symbols.gmt")
c2_kegg <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c2.cp.kegg.v6.2.symbols.gmt")
c2_reactome <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c2.cp.reactome.v6.2.symbols.gmt")
c3 <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c3.all.v6.2.symbols.gmt")
c4 <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c4.all.v6.2.symbols.gmt")
c5_mf <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c5.mf.v6.2.symbols.gmt")
c5_bp <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c5.bp.v6.2.symbols.gmt")
c6 <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c6.all.v6.2.symbols.gmt")
c7 <- read.gmt("/public/data/VM_backup/biodata/MsigDB/c7.all.v6.2.symbols.gmt")
#-=---------

goGSEA <- function(DEG, prefix = NULL, pvalue = 0.01, adj.pvalue = 0.05, destdir = "~/projects/tumor-immunogenicity-score/report/results/GSEA_results") {
  library(clusterProfiler)
  library(openxlsx)
  library(tidyverse)

  filterDEG <- subset(DEG, subset = P.Value < pvalue & adj.P.Val < adj.pvalue)
  filterDEG$SYMBOL <- rownames(filterDEG)
  filterDEG <- filterDEG %>%
    arrange(desc(logFC), adj.P.Val)
  geneList <- filterDEG$logFC
  names(geneList) <- filterDEG$SYMBOL

  res <- list()
  if (base::exists("hallmark")) res$hallmark <- GSEA(geneList, TERM2GENE = hallmark, verbose = FALSE)
  # if (base::exists("c1")) res$c1 = GSEA(geneList, TERM2GENE=c1, verbose=FALSE)
  if (base::exists("c2_kegg")) res$c2_kegg <- GSEA(geneList, TERM2GENE = c2_kegg, verbose = FALSE)
  if (base::exists("c2_reactome")) res$c2_reactome <- GSEA(geneList, TERM2GENE = c2_reactome, verbose = FALSE)
  # if (base::exists("c3")) res$c3 = GSEA(geneList, TERM2GENE=c3, verbose=FALSE)
  # if (base::exists("c4")) res$c4 = GSEA(geneList, TERM2GENE=c4, verbose=FALSE)
  if (base::exists("c5_mf")) res$c5_mf <- GSEA(geneList, TERM2GENE = c5_mf, verbose = FALSE)
  if (base::exists("c5_bp")) res$c5_bp <- GSEA(geneList, TERM2GENE = c5_bp, verbose = FALSE)
  if (base::exists("c6")) res$c6 <- GSEA(geneList, TERM2GENE = c6, verbose = FALSE)
  if (base::exists("c7")) res$c7 <- GSEA(geneList, TERM2GENE = c7, verbose = FALSE)

  getResultList <- lapply(res, function(x) x@result)
  if (!dir.exists(destdir)) dir.create(destdir)
  outpath <- file.path(destdir, prefix)
  write.xlsx(x = getResultList, file = paste0(outpath, ".xlsx"))
  return(res)
}


# remove STAD, CHOL, KICH and DLBC
DEG_pancan2 <- DEG_pancan2[setdiff(names(DEG_pancan2), c("STAD", "CHOL", "KICH", "DLBC"))]
GSEA_list <- Map(goGSEA, DEG_pancan2, names(DEG_pancan2))
save(GSEA_list, file = "results/GSEA_results_rm_notEnriched.RData")

#------- GSEA example plot
# load("results/GSEA_results.RData")
load("results/GSEA_results_rm_notEnriched.RData")
library(clusterProfiler)

gseaplot(GSEA_list$SKCM$hallmark, geneSetID = "HALLMARK_INTERFERON_GAMMA_RESPONSE")

# gseaplot(egmt2, geneSetID = "INTEGRAL_TO_PLASMA_MEMBRANE")
# gseaplot(res$hallmark, geneSetID = "HALLMARK_INTERFERON_GAMMA_RESPONSE")

#------ get main result cloumn
gsea_results <- lapply(GSEA_list, function(x) {
  # x@result %>% select()
  lapply(x, function(gsea) {
    gsea@result %>% dplyr::select(ID, setSize, enrichmentScore, NES, pvalue, qvalues)
  })
})

save(gsea_results, file = "results/GSEA_results_notEnriched_small.RData")
rm(GSEA_list)
gc()

#----- plot
summariseGSEA <- function(pathway = NULL) {
  purrr::reduce(Map(function(x, y, pathway) {
    if (nrow(x[[pathway]]) == 0) {
      res <- NULL
    } else {
      res <- x[[pathway]]
      res$Project <- y
    }
    res
  }, gsea_results, names(gsea_results), pathway), rbind)
}

gsea_summary <- list()
gsea_summary$hallmark <- summariseGSEA(pathway = "hallmark")
# gsea_summary$c2_kegg = summariseGSEA(pathway = "c2_kegg")
gsea_summary$c2_reactome <- summariseGSEA(pathway = "c2_reactome")
gsea_summary$c5_mf <- summariseGSEA(pathway = "c5_mf")
gsea_summary$c5_bp <- summariseGSEA(pathway = "c5_bp")
gsea_summary$c6 <- summariseGSEA(pathway = "c6")
gsea_summary$c7 <- summariseGSEA(pathway = "c7")

save(gsea_summary, file = "results/GSEA_summary_notEnriched.RData")

## plot really
load("../data/df_combine_gsva_clinical.RData")

df.gsva %>%
  filter(!is.na(APM)) %>%
  group_by(Project) %>%
  summarize(MedianAPM = median(APM), N = n()) %>%
  arrange(MedianAPM) -> sortAPM
sortAPM %>% filter(Project != "DLBC") -> sortAPM

library(scales)
gsea_summary$hallmark %>%
  ggplot(mapping = aes(x = Project, y = ID)) +
  geom_tile(aes(fill = NES)) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
  scale_x_discrete(limits = sortAPM$Project) + theme_classic() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1))

# df_wide = reshape2::dcast(gsea_summary$hallmark, ID ~ Project, value.var="NES", fill = 0)

library(pheatmap)

plotPathway <- function(df, save = FALSE, path = NULL, silent = FALSE) {
  df_wide <- reshape2::dcast(df, ID ~ Project, value.var = "NES", fill = 0)

  breaksList <- seq(-max(df_wide[, -1], na.rm = TRUE), max(df_wide[, -1], na.rm = TRUE), by = 0.01)
  pheatmap(df_wide %>% column_to_rownames(var = "ID"),
    color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
    breaks = breaksList,
    # annotation_col = annotation_col,
    fontsize_row = 8, fontsize_col = 8, silent = silent,
    cellheight = 10, cellwidth = 10, filename = ifelse(save == FALSE, NA, path)
  )
}

gg <- plotPathway(gsea_summary$hallmark, silent = F, path = "results/GSEA_results_plot/Hallmark_Enriched.pdf", save = TRUE)
# gg = plotPathway(gsea_summary$c2_kegg, silent = F, path = "results/GSEA_results_plot/KEGG_Enriched.pdf", save = TRUE)
gg <- plotPathway(gsea_summary$c2_reactome, silent = F, path = "results/GSEA_results_plot/Reactome_Enriched.pdf", save = TRUE)
gg <- plotPathway(gsea_summary$c5_mf, silent = F, path = "results/GSEA_results_plot/GO_MolecuFunction_Enriched.pdf", save = TRUE)
gg <- plotPathway(gsea_summary$c5_bp, silent = F, path = "results/GSEA_results_plot/GO_BiologicalProcess_Enriched.pdf", save = TRUE)
gg <- plotPathway(gsea_summary$c6, silent = F, path = "results/GSEA_results_plot/C6_oncogenicsignatures_Enriched.pdf", save = TRUE)
gg <- plotPathway(gsea_summary$c7, silent = F, path = "results/GSEA_results_plot/C7_immunologicsignatures_Enriched.pdf", save = TRUE)

# gg


# _-------- rank pheatmap by NES value
plotPathway2 <- function(df, save = FALSE, path = NULL, silent = FALSE) {
  df_wide <- reshape2::dcast(df, ID ~ Project, value.var = "NES", fill = 0)
  df_wide <- df_wide[order(rowMeans(df_wide[, -1]), decreasing = TRUE), ]
  rownames(df_wide) <- NULL

  breaksList <- seq(-max(df_wide[, -1], na.rm = TRUE), max(df_wide[, -1], na.rm = TRUE), by = 0.01)

  pheatmap(df_wide %>% column_to_rownames(var = "ID"),
    color = colorRampPalette(c("blue", "white", "red"))(length(breaksList)),
    breaks = breaksList, cluster_rows = FALSE,
    # annotation_col = annotation_col,
    fontsize_row = 8, fontsize_col = 8, silent = silent,
    cellheight = 10, cellwidth = 10, filename = ifelse(save == FALSE, NA, path)
  )
}

gg <- plotPathway2(gsea_summary$c2_reactome, silent = F, path = "results/GSEA_results_plot/Reactome_Enriched2.pdf", save = TRUE)
```


## Session Info

```{r sessionInfo}
sessionInfo()
```

